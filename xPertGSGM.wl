(* ::Package:: *)

BeginPackage["xPertGSGM`"];


xFrame::usage="xFrame[coords,l,n,r] builds a chart with coordinates {coords}, and the metric generated by the frame {l, n} (both with indices down), with warping factor r. It outputs two things: (i) an association, with the values of the perturbation scalars \[Mu],\[Nu],U,W,\!\(\*SuperscriptBox[\(v\), \(2\)]\), and (ii) a function to replace the frame derivatives with partial derivatives."
vacuumBG::usage="Utility function to set the background stress energy tensor to zero."
vacuumPert::usage="Utility function to set all the perturbations of the stress energy tensor to zero."
d0::usage="Short-hand for the partial derivative along the first coordinate"
d1::usage="Short-hand for the partial derivative along the second coordinate"
commutePDs::usage="commutePDs[expr] changes the order of the partial derivatives: 01 --> 10"
commutePDs2::usage="commutePDs2[expr] changes the order of the partial derivatives: 10 --> 01"
CoeffSimplify::usage="CoeffSimplify[expr, vars] simplifies individually each of the coefficients of expression expr with respect to the variables vars."
EvenSETRules::usage="EvenSETRules[SET] takes an Association and turns it into a replacement rule, for the variables that capture the degrees of freedom of the even parity perturbations to the SET."
OddSETRules::usage="OddSETRules[SET] takes an Association and turns it into a replacement rule, for the variables that capture the degrees of freedom of the odd parity perturbations to the SET."


(* ::Subsubsection::Closed:: *)
(*0. Load minimal packages that are necessary*)


Needs["xAct`xTensor`"];
Needs["xAct`xCoba`"];


<<xAct`ShowTime1`;
$ShowTimeThreshold=0.1;
$PrePrint=ScreenDollarIndices;
$DefInfoQ=False;


(* ::Subsubsection:: *)
(*1. Define 2D metric & tensors*)


DefManifold[M2, 2,{A,B,C,D,F}]
DefMetric[-1,g2[-A,-B],CD,{":","\[Del]"},PrintAs->"\!\(\*SuperscriptBox[\(g\), \((2)\)]\)"]
DefTensor[r[],{M2}]


DefTensor[U[],M2];
DefTensor[W[],M2];
DefTensor[mu[],M2,PrintAs->"\[Mu]"];
DefTensor[nu[],M2,PrintAs->"\[Nu]"];


DefTensor[tS[],M2, PrintAs->"\!\(\*SubscriptBox[\(t\), \(S\)]\)"];
DefTensor[tP[],M2,PrintAs->"\!\(\*SubscriptBox[\(t\), \(P\)]\)"];
DefTensor[tQ[],M2,PrintAs->"\!\(\*SubscriptBox[\(t\), \(Q\)]\)"];
DefTensor[tG[],M2,PrintAs->"\!\(\*SubscriptBox[\(t\), \(G\)]\)"];


(* ::Text:: *)
(*Define derivatives (some inspiration taken from Leo Stein CCE example)*)


DefInertHead[\[ScriptCapitalD],PrintAs->"\[ScriptCapitalD]",LinearQ->True]
DefInertHead[\[GothicCapitalD],PrintAs->"\[GothicCapitalD]",LinearQ->True]


xAct`xTensor`Private`MakeLinearDerivative[{\[ScriptCapitalD],\[ScriptCapitalD]},True];
xAct`xTensor`Private`MakeLinearDerivative[{\[GothicCapitalD],\[GothicCapitalD]},True];


(* ::Text:: *)
(*We also define the tensors for the perturbation, so that when we load Einstein's equations, they look nice*)


DefTensor[\[Theta]l[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[Theta]\), \(l\)]\)",Blue]];
DefTensor[\[Theta]n[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[Theta]\), \(n\)]\)",Blue]];
DefTensor[kl[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(k\), \(l\)]\)",Blue]];
DefTensor[kn[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(k\), \(n\)]\)",Blue]];
DefTensor[\[Theta]S[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[Theta]\), \(S\)]\)",Blue]];


DefTensor[hg[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(h\), \(g\)]\)",Blue]];
DefTensor[hp[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(h\), \(p\)]\)",Blue]];
DefTensor[hq[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(h\), \(q\)]\)",Blue]];
DefTensor[hS[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(h\), \(S\)]\)",Blue]];

DefTensor[\[ScriptCapitalT]g[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[ScriptCapitalT]\), \(g\)]\)",Blue]];
DefTensor[\[ScriptCapitalT]p[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[ScriptCapitalT]\), \(p\)]\)",Blue]];
DefTensor[\[ScriptCapitalT]q[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[ScriptCapitalT]\), \(q\)]\)",Blue]];
DefTensor[\[ScriptCapitalT]l[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[ScriptCapitalT]\), \(l\)]\)",Blue]];
DefTensor[\[ScriptCapitalT]n[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[ScriptCapitalT]\), \(n\)]\)",Blue]];
DefTensor[\[ScriptCapitalT]S[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[ScriptCapitalT]\), \(S\)]\)",Blue]];
DefTensor[\[ScriptCapitalT]2S[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[OverscriptBox[\(\[ScriptCapitalT]\), \(~\)], \(S\)]\)",Blue]];


(* ::Text:: *)
(*And the perturbation of the SET*)


DefTensor[\[ScriptE][],M2];
DefTensor[\[ScriptP][],M2];
DefTensor[cs[],M2,PrintAs->"\!\(\*SubscriptBox[\(c\), \(s\)]\)"];
DefTensor[\[Beta][],M2,PrintAs->ColorString["\[Beta]",Blue]];
DefTensor[\[Alpha][],M2, PrintAs->ColorString["\[Alpha]", Blue]];
DefTensor[\[Gamma][],M2, PrintAs->ColorString["\[Gamma]", Blue]];
DefTensor[\[Omega][],M2, PrintAs->ColorString["\[Omega]", Blue]];
DefTensor[H[],M2, PrintAs->ColorString["H", Blue]];
\[Omega]2H ={\[Omega][]-> (\[ScriptE][]+\[ScriptP][])/(cs[]^2 \[ScriptE][]) H[]};


(* ::Text:: *)
(*And the viscosities, so that they appear in color*)


(*DefConstantSymbol[\[Eta], PrintAs->ColorString["\!\(\*OverscriptBox[\(\[Eta]\), \(^\)]\)",Orange]];
DefConstantSymbol[\[Tau], PrintAs->ColorString["\!\(\*OverscriptBox[\(\[Tau]\), \(^\)]\)",Orange]];
DefConstantSymbol[Ry, PrintAs->ColorString["Re",Orange]];
DefConstantSymbol[LENG, PrintAs->ColorString["L",Orange]];*)


DefTensor[\[Tau]E[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[Tau]\), \(e\)]\)",Orange]];
DefTensor[\[Tau]P[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[Tau]\), \(P\)]\)",Orange]];
DefTensor[\[Tau]Q[],M2,PrintAs->ColorString["\!\(\*SubscriptBox[\(\[Tau]\), \(Q\)]\)",Orange]];
DefTensor[\[Zeta][],M2,PrintAs->ColorString["\[Zeta]",Orange]];
DefTensor[\[Eta][],M2,PrintAs->ColorString["\[Eta]",Orange]];


Begin["`Private`"];


(* ::Subsubsection::Closed:: *)
(*2. Build frame*)


xFrame[coords_, l$frame_, n$frame_, rRule_] := Module[
{matrix,imatrix,metric,imetric,metricCD,onBGrepl},
DefChart[SS, M2, {0,1},coords];
SS /: CIndexForm[0,SS]=StringReplace[ToString[coords[[1]]],{"["->"","]"->""}];
SS /: CIndexForm[1,SS]=StringReplace[ToString[coords[[2]]],{"["->"","]"->""}];
\[ScriptL] = CTensor[l$frame,{-SS}];
\[ScriptN] = CTensor[n$frame,{-SS}];
matrix=  Table[-\[ScriptL][[1,A]]\[ScriptL][[1,B]]+\[ScriptN][[1,A]]\[ScriptN][[1,B]],{A,1,2},{B,1,2}];
imatrix = Inverse[matrix];
metric=CTensor[matrix,{-SS,-SS}];
imetric=Inv[metric];
metricCD=CovDOfMetric[metric];
onBGrepl = {g2[A_?DownIndexQ,B_?DownIndexQ]:>metric[A,B], g2[A_?UpIndexQ,B_?UpIndexQ]:>imetric[A,B]};

fr = <|
"\[Mu]" -> ( metricCD[A][\[ScriptL][-A]]//ToValues)/.onBGrepl,
"\[Nu]" -> (metricCD[A][\[ScriptN][-A]]//ToValues)/.onBGrepl,
"U" ->( \[ScriptL][A] metricCD[-A][r[]]/r[]/.rRule//ContractBasis//ToValues)/.onBGrepl,
"W" -> ( \[ScriptN][A] metricCD[-A][r[]]/r[]/.rRule//ContractBasis//ToValues)/.onBGrepl,
"v2" -> (metricCD[-A][r[]] metricCD[A][r[]]/r[]^2/.rRule//ContractBasis//ToValues)/.onBGrepl
|>;

changeDs[expr_]:=Which[
ToString@Head@Delete[expr,0]=="\[ScriptCapitalD]" && ToString@Head@expr=="\[ScriptCapitalD]",  ( \[ScriptL][A]metricCD[-A][\[ScriptL][B]metricCD[-B][Delete[Delete[expr,0],0]]]//ContractBasis//ToValues)/.onBGrepl,
ToString@Head@Delete[expr,0]=="\[GothicCapitalD]" && ToString@Head@expr=="\[GothicCapitalD]",  ( \[ScriptN][A]metricCD[-A][\[ScriptN][B]metricCD[-B][Delete[Delete[expr,0],0]]]//ContractBasis//ToValues)/.onBGrepl,
ToString@Head@Delete[expr,0]=="\[GothicCapitalD]" && ToString@Head@expr=="\[ScriptCapitalD]",  ( \[ScriptL][A]metricCD[-A][\[ScriptN][B]metricCD[-B][Delete[Delete[expr,0],0]]]//ContractBasis//ToValues)/.onBGrepl,
ToString@Head@Delete[expr,0]=="\[ScriptCapitalD]" && ToString@Head@expr=="\[GothicCapitalD]",  ( \[ScriptN][A]metricCD[-A][\[ScriptL][B]metricCD[-B][Delete[Delete[expr,0],0]]]//ContractBasis//ToValues)/.onBGrepl,
ToString@Head[expr]=="\[ScriptCapitalD]",( \[ScriptL][A]metricCD[-A][Delete[expr,0]]//ContractBasis//ToValues)/.onBGrepl,
ToString@Head[expr]=="\[GothicCapitalD]", (\[ScriptN][A]metricCD[-A][Delete[expr,0]]//ContractBasis//ToValues) /.onBGrepl,
2==2, expr
];

{fr, changeDs}

]


(* ::Subsubsection:: *)
(*Generate replacement rules from a SET struct*)


OddSETRules[set_?AssociationQ]:={
tP[]->set["tp"],
tG[]->set["tg"],
tQ[]->set["tq"],
tS[]->set["ts"],
\[Theta]l[]->set["\[Theta]l"],
\[Theta]n[]->set["\[Theta]n"],
\[Theta]S[]->set["\[Theta]s"]
}

EvenSETRules[set_?AssociationQ]:={
tP[]->set["tp"],
tG[]->set["tg"],
tQ[]->set["tq"],
tS[]->set["ts"],
\[ScriptCapitalT]p[]->set["\[ScriptCapitalT]p"],
\[ScriptCapitalT]g[]->set["\[ScriptCapitalT]g"],
\[ScriptCapitalT]q[]->set["\[ScriptCapitalT]q"],
\[ScriptCapitalT]l[]->set["\[ScriptCapitalT]l"],
\[ScriptCapitalT]n[]->set["\[ScriptCapitalT]n"],
\[ScriptCapitalT]S[]->set["\[ScriptCapitalT]s"],
\[ScriptCapitalT]2S[]->set["\[ScriptCapitalT]2s"]
}


(* ::Subsubsection:: *)
(*Auxiliary functions that are useful*)


vacuumBG = {tP[]->0, tG[]->0, tQ[]->0, tS[]->0};
vacuumPert={\[Theta]l[]->0, \[Theta]n[]->0, \[Theta]S[]->0};


d0[a_] := PDxPertGSGM`Private`SS[{0,-xPertGSGM`Private`SS}][a];
d1[a_] :=  PDxPertGSGM`Private`SS[{1,-xPertGSGM`Private`SS}][a];


commutePDs[expr_] := CommuteCovDs[expr,PDxPertGSGM`Private`SS,{{0,-xPertGSGM`Private`SS},{1,-xPertGSGM`Private`SS}}];
commutePDs2[expr_] := CommuteCovDs[expr,PDxPertGSGM`Private`SS,{{1,-xPertGSGM`Private`SS},{0,-xPertGSGM`Private`SS}}];


CoeffSimplify[F_,vars_]:=Module[
	(* Internals *)
	{CollectedF,Ans},
	(* Create table of derivatives *)
	CollectedF = Collect[Simplify@F,vars];
	Ans = CollectedF;
	Table[
		Ans = Ans/.{
					Coefficient[CollectedF,vars[[kkkk]]] :> Simplify[Coefficient[CollectedF,vars[[kkkk]]]]
					};
		,{kkkk,Length[vars]}
	];
	Return[Ans];
]


(* ::Subsubsection:: *)
(*End*)


End[];


EndPackage[];
